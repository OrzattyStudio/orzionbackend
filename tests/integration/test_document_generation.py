import pytest
import sys
import os

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../..'))

from services.sandbox_service import SandboxService


class TestDocumentGeneration:
    """Integration tests for document generation and sandbox security."""
    
    @pytest.mark.asyncio
    async def test_generate_simple_pdf(self):
        """Test generating a simple PDF document."""
        code = """
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter

c = canvas.Canvas(output_file, pagesize=letter)
c.drawString(100, 750, "Hello, this is a test PDF!")
c.drawString(100, 730, "Generated by Orzion Chat")
c.save()
"""
        
        result = await SandboxService.execute_code(
            code=code,
            doc_type="pdf",
            filename="test_simple"
        )
        
        assert result['success'] is True
        assert result['filename'].endswith('.pdf')
        assert result['size'] > 0
        assert os.path.exists(result['path'])
        
        if os.path.exists(result['path']):
            os.remove(result['path'])
    
    @pytest.mark.asyncio
    async def test_generate_pdf_with_table(self):
        """Test generating a PDF with tables."""
        code = """
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle
from reportlab.lib import colors

doc = SimpleDocTemplate(output_file, pagesize=letter)
elements = []

data = [
    ['Name', 'Age', 'City'],
    ['Alice', '25', 'New York'],
    ['Bob', '30', 'San Francisco'],
    ['Charlie', '35', 'Los Angeles']
]

table = Table(data)
table.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
    ('FONTSIZE', (0, 0), (-1, 0), 14),
    ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
    ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
    ('GRID', (0, 0), (-1, -1), 1, colors.black)
]))

elements.append(table)
doc.build(elements)
"""
        
        result = await SandboxService.execute_code(
            code=code,
            doc_type="pdf",
            filename="test_table"
        )
        
        assert result['success'] is True
        assert result['filename'].endswith('.pdf')
        assert result['size'] > 0
        
        if os.path.exists(result['path']):
            os.remove(result['path'])
    
    @pytest.mark.asyncio
    async def test_generate_zip_file(self):
        """Test generating a ZIP file."""
        code = """
import zipfile

with zipfile.ZipFile(output_file, 'w') as zipf:
    zipf.writestr('file1.txt', 'This is file 1')
    zipf.writestr('file2.txt', 'This is file 2')
    zipf.writestr('data.json', '{"test": "data"}')
"""
        
        result = await SandboxService.execute_code(
            code=code,
            doc_type="zip",
            filename="test_archive"
        )
        
        assert result['success'] is True
        assert result['filename'].endswith('.zip')
        assert result['size'] > 0
        
        if os.path.exists(result['path']):
            os.remove(result['path'])
    
    @pytest.mark.asyncio
    async def test_sandbox_blocks_os_system(self):
        """Test that sandbox blocks os.system calls."""
        malicious_code = """
import os
os.system('echo "malicious"')
"""
        
        result = await SandboxService.execute_code(
            code=malicious_code,
            doc_type="pdf",
            filename="malicious"
        )
        
        assert result['success'] is False
        assert 'error' in result
        assert 'no permitidas' in result['error'].lower() or 'not allowed' in result['error'].lower()
    
    @pytest.mark.asyncio
    async def test_sandbox_blocks_subprocess(self):
        """Test that sandbox blocks subprocess calls."""
        malicious_code = """
import subprocess
subprocess.run(['ls', '-la'])
"""
        
        result = await SandboxService.execute_code(
            code=malicious_code,
            doc_type="pdf",
            filename="malicious"
        )
        
        assert result['success'] is False
        assert 'error' in result
    
    @pytest.mark.asyncio
    async def test_sandbox_blocks_eval(self):
        """Test that sandbox blocks eval calls."""
        malicious_code = """
eval('print("malicious")')
"""
        
        result = await SandboxService.execute_code(
            code=malicious_code,
            doc_type="pdf",
            filename="malicious"
        )
        
        assert result['success'] is False
        assert 'error' in result
    
    @pytest.mark.asyncio
    async def test_sandbox_blocks_exec(self):
        """Test that sandbox blocks exec calls."""
        malicious_code = """
exec('import os')
"""
        
        result = await SandboxService.execute_code(
            code=malicious_code,
            doc_type="pdf",
            filename="malicious"
        )
        
        assert result['success'] is False
        assert 'error' in result
    
    @pytest.mark.asyncio
    async def test_sandbox_blocks_file_write(self):
        """Test that sandbox blocks unauthorized file writes."""
        malicious_code = """
with open('/tmp/malicious.txt', 'w') as f:
    f.write('malicious')
"""
        
        result = await SandboxService.execute_code(
            code=malicious_code,
            doc_type="pdf",
            filename="malicious"
        )
        
        assert result['success'] is False
        assert 'error' in result
    
    @pytest.mark.asyncio
    async def test_sandbox_blocks_unauthorized_import(self):
        """Test that sandbox blocks unauthorized imports."""
        malicious_code = """
import requests
requests.get('http://malicious.com')
"""
        
        result = await SandboxService.execute_code(
            code=malicious_code,
            doc_type="pdf",
            filename="malicious"
        )
        
        assert result['success'] is False
        assert 'error' in result
        assert 'no permit' in result['error'].lower() or 'not allowed' in result['error'].lower()
    
    @pytest.mark.asyncio
    async def test_empty_code_validation(self):
        """Test that empty code is rejected."""
        result = await SandboxService.execute_code(
            code="",
            doc_type="pdf",
            filename="empty"
        )
        
        assert result['success'] is False
        assert 'error' in result
    
    @pytest.mark.asyncio
    async def test_code_length_limit(self):
        """Test that code exceeding max length is rejected."""
        long_code = "# " + "x" * (SandboxService.MAX_CODE_LENGTH + 100)
        
        result = await SandboxService.execute_code(
            code=long_code,
            doc_type="pdf",
            filename="toolong"
        )
        
        assert result['success'] is False
        assert 'error' in result
        assert 'l√≠mite' in result['error'].lower() or 'limit' in result['error'].lower()
